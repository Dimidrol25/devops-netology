### Домашнее задание к занятию "6.6. Troubleshooting"  

## Задача 1  

В первую очередь необходимо найти `opid` зависшей операции. Для этого необходимо выполнить запрос:  
```
db.currentOp({ "active" : true, "secs_running" : { "$gt" : 180 }})

{
    "inprog" : [
        {
            //...
            "opid" : XXXXX,
            "secs_running" : NumberLong(123)
            //...
        }
    ]
}
```

Затем принудительно завершить операцию:  
`db.killOp(XXXXX)`  

Для решения проблес с зависающими запросами можно использовать метод `maxTimeMS()` для установки временного предела исполнения операций.  
Также можно провести анализ с помощью `Database Profiler` и `executionStats`. Исходя из полученных данных можно попробовать оптимизировать базу данных путем добавления индексов, шардирования и прочее.  

## Задача 2  

Скорее всего вся память занята истекшими ключами, но еще не удаленными. Redis заблокировался, чтобы вывести из базы данных удаленные ключи и снизить их количество до уровня менее 25%. так как Redis однопоточное приложение, то все операции блокируются до тех пор, пока не выполнится очистка. Имеет смысл поиграть со значением hz в redis.conf.

## Задача 3  

Как вы думаете, почему это начало происходить и как локализовать проблему?  

Исходя из документации `MySQL` возможны три причины:  
1. Слишком объемные запросы на миллионы строк - рекомендуется увеличение параметра `net_read_timeout`;  
2. Малое значение параметра `connect_timeout` - клиент не успевает установить соединение;  
3. Размер сообщения/запроса превышает размер буфера `max_allowed_packet` на сервере или `max_allowed_packet` на стороне клиента.  

Какие пути решения данной проблемы вы можете предложить?  
1. Увеличить на сервере `MySQL` `wait_timeout`, `max_allowed_packet`, `net_write_timeout` и `net_read_timeout`;  
2. В `SQLAlchemy` уменьшить `pool_recycle`, `wait_timeout`;  
3. При исчезновении ошибки `Lost connection to MySQL server during query` возвращать по одному параметры в исходное состояние для локализации проблемы.  

## Задача 4  

Как вы думаете, что происходит?  
Postgres недостаточно памяти. Когда у сервера/процесса заканчивается память, операционная система предлагает два решения: обрушить систему или завершить процесс, который использует слишком много памяти.  
Out-Of-Memory Killer (oomkiller) - это процесс, который завершает приложение, чтобы спасти ядро от сбоя.  

Как бы вы решили данную проблему?  
1. По возможности добавить оперативную память, попробовать оптимизировать потребление ОЗУ другими приложениями;  
2. Произвести тонкую настройку использования памяти в Postgres:  
- max_connections  
- shared_buffer  
- work_mem  
- effective_cache_size  
- maintenance_work_mem  
